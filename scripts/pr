#!/usr/bin/env bash
set -euo pipefail

die() {
  echo "error: $*" >&2
  exit 1
}

note() {
  echo "$*" >&2
}

need_cmd() {
  command -v "$1" >/dev/null 2>&1 || die "missing required command: $1"
}

usage() {
  cat >&2 <<'EOF'
IRUN PR workflow helper.

Usage:
  scripts/pr start <topic>
  scripts/pr sync
  scripts/pr ship [--no-merge]

Environment:
  IRUN_BRANCH_PREFIX   Branch prefix for `start` (default: myfunc)

Notes:
  - `sync` pushes the current branch to origin, creates/updates a PR to `main`,
    and fast-forwards your local `main` from `origin/main` (then switches back).
  - `ship` expects a clean working tree (commit your changes first).
  - If GitHub reports merge conflicts, the script stops and you resolve them manually.
EOF
}

repo_root() {
  git rev-parse --show-toplevel 2>/dev/null
}

sanitize_topic() {
  # Conservative: keep common branch-safe chars, convert whitespace to '-'.
  # Mac default bash lacks some GNU utils; keep this simple and predictable.
  echo "$1" \
    | tr '[:space:]' '-' \
    | tr -cd '[:alnum:]._/-' \
    | sed -e 's#//*#/#g' -e 's#^-##' -e 's#-$##'
}

ensure_clean_worktree() {
  if [ -n "$(git status --porcelain)" ]; then
    die "working tree is not clean; commit/stash changes first"
  fi
}

ensure_gh_auth() {
  if ! gh auth status -h github.com >/dev/null 2>&1; then
    die "gh is not authenticated; run: gh auth login -h github.com"
  fi
}

pr_url_for_number() {
  local pr="$1"
  gh pr view "$pr" --json url --jq .url
}

cmd_start() {
  local prefix topic branch current
  prefix="${IRUN_BRANCH_PREFIX:-myfunc}"
  topic="${1:-}"
  [ -n "$topic" ] || die "usage: scripts/pr start <topic>"

  topic="$(sanitize_topic "$topic")"
  [ -n "$topic" ] || die "invalid topic after sanitization"

  branch="${prefix}/${topic}"
  current="$(git rev-parse --abbrev-ref HEAD)"

  if [ "$current" = "$branch" ]; then
    note "already on branch: $branch"
    return 0
  fi

  git switch -c "$branch"
  note "created and switched to: $branch"
}

pr_number_for_branch() {
  # Print PR number for the given head branch (open PRs only), or nothing.
  gh pr list --state open --head "$1" --json number --jq '.[0].number' 2>/dev/null || true
}

pr_view_field() {
  local pr="$1"
  local field="$2"
  gh pr view "$pr" --json "$field" --jq ".$field"
}

ensure_branch_pr() {
  local branch="$1"

  if [ "$branch" = "main" ]; then
    die "refusing to run from 'main'; create a topic branch first (try: scripts/pr start <topic>)"
  fi

  if ! git remote get-url origin >/dev/null 2>&1; then
    die "missing git remote 'origin'"
  fi

  # Ensure origin/main is up to date for the "has commits?" check.
  git fetch origin main >/dev/null

  local ahead
  ahead="$(git rev-list --count "origin/main..HEAD" 2>/dev/null || echo "0")"
  if [ "$ahead" = "0" ]; then
    die "no commits ahead of origin/main on '$branch' (nothing to push)"
  fi

  note "pushing: $branch"
  git push -u origin HEAD

  local pr
  pr="$(pr_number_for_branch "$branch")"
  if [ -z "$pr" ]; then
    note "creating PR for: $branch -> main"
    gh pr create --base main --head "$branch" --fill >/dev/null
    pr="$(pr_number_for_branch "$branch")"
  fi
  [ -n "$pr" ] || die "failed to find/create PR for head '$branch'"

  # Export for callers.
  PR_NUMBER="$pr"
  PR_URL="$(pr_url_for_number "$pr")"
  PR_MERGE_STATE="$(pr_view_field "$pr" mergeStateStatus)"
}

sync_local_main() {
  local return_branch="$1"

  note "syncing local main with origin/main..."
  git fetch origin main >/dev/null
  git switch main >/dev/null
  if git pull --ff-only origin main >/dev/null; then
    :
  else
    note "warning: could not fast-forward local main. Your local main may be divergent."
    note "hint: inspect with: git log --oneline --decorate --graph --max-count=30 main origin/main"
  fi

  git switch "$return_branch" >/dev/null
}

cmd_sync() {
  need_cmd git
  need_cmd gh

  ensure_gh_auth
  ensure_clean_worktree

  local branch
  branch="$(git rev-parse --abbrev-ref HEAD)"

  PR_NUMBER=""
  PR_URL=""
  PR_MERGE_STATE=""
  ensure_branch_pr "$branch"

  note "PR: $PR_URL"

  if [ "$PR_MERGE_STATE" = "CONFLICTING" ]; then
    die "merge conflict detected on GitHub; resolve manually (rebase/merge main), push, then re-run: scripts/pr sync"
  fi

  sync_local_main "$branch"
  note "done"
}

cmd_ship() {
  local no_merge="0"
  if [ "${1:-}" = "--no-merge" ]; then
    no_merge="1"
    shift
  fi
  [ "${1:-}" = "" ] || die "usage: scripts/pr ship [--no-merge]"

  need_cmd git
  need_cmd gh

  ensure_gh_auth
  ensure_clean_worktree

  local branch
  branch="$(git rev-parse --abbrev-ref HEAD)"
  local pr

  PR_NUMBER=""
  PR_URL=""
  PR_MERGE_STATE=""
  ensure_branch_pr "$branch"
  pr="$PR_NUMBER"

  note "PR: $PR_URL"

  if [ "$PR_MERGE_STATE" = "CONFLICTING" ]; then
    die "merge conflict detected on GitHub; resolve manually, push, then re-run: scripts/pr ship"
  fi

  if [ "$no_merge" = "1" ]; then
    note "skipping merge (--no-merge)"
    return 0
  fi

  note "merging (squash) and deleting branch on GitHub..."
  if gh pr merge "$pr" --squash --auto --delete-branch >/dev/null 2>&1; then
    :
  else
    # Auto-merge may be disabled; try direct merge.
    gh pr merge "$pr" --squash --delete-branch
  fi

  # If auto-merge was enabled but not merged yet (checks pending), don't pretend it landed.
  local pr_state
  pr_state="$(pr_view_field "$pr" state)"
  if [ "$pr_state" != "MERGED" ]; then
    note "PR is not merged yet (state=$pr_state). If checks are required, GitHub will merge when ready."
    return 0
  fi

  sync_local_main "$branch"

  # Best-effort: delete the local topic branch if it exists and is merged.
  if git show-ref --verify --quiet "refs/heads/$branch"; then
    git branch -d "$branch" >/dev/null 2>&1 || true
  fi

  note "done"
}

main() {
  local root cmd
  root="$(repo_root)" || die "not in a git repository"
  cd "$root"

  cmd="${1:-help}"
  shift || true

  case "$cmd" in
    start) cmd_start "${1:-}" ;;
    sync) cmd_sync "$@" ;;
    ship) cmd_ship "$@" ;;
    -h|--help|help) usage ;;
    *) die "unknown command: $cmd (try: scripts/pr --help)" ;;
  esac
}

main "$@"
